// automatically generated by Xtext
grammar no.hal.scxml.Scxmlxt with org.eclipse.xtext.common.Terminals 

import "http://no.hal/scxml/scxmlxt.ecore"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

StateMachine :
	(imports += ResourceImport)*
	(
	  (states += State)
	| (transitions += AbstractTransition)
	| (variables += VarDef)
	)*;

ResourceImport : DomainModelImport | DomainDataImport;

DomainModelImport :	'domain'? 'model' importURI=STRING ';';
DomainDataImport :	'domain'? 'data'  importURI=STRING ';';

State :
	(initialTransition = InitialTransition)?
	name=ID (';' | ('{' (
		(states += State)
		| (transitions += AbstractTransition)
		| (variables += VarDef)
		)*
	'}')
	);

InitialTransition:
	//	('->' target=[State] |	target=[State] '<-')
	{InitialTransition} '->'
	('do' action=Action)?
	;

AbstractState : StateMachine | State;

AbstractTransition : Transition | InternalTransition;

Transition :
	// (source=[State|QNAME] '->' target=[State|QNAME] | target=[State|QNAME] '<-' source=[State|QNAME])
	('->' target=[State|QNAME] | target=[State|QNAME] '<-')
	('on' event=Event)?
	('if' condition=Condition)?
	('do' action=Action)?
	';';

InternalTransition :
	('on' event=Event)?
	('if' condition=Condition)?
	'do' action=Action
	';';

Event : SymbolicEvent | TransitionEvent | EnterEvent | ExitEvent | ScriptEvent | TimerEvent;

SymbolicEvent : name=ID '!';
TransitionEvent :
	  (source=[State|QNAME] '->' target=[State|QNAME] | target=[State|QNAME] '<-' source=[State|QNAME])
	| (                     '->' target=[State|QNAME] | target=[State|QNAME] '<-'                     ) // implicit EnterEvent
	| (source=[State|QNAME] '->'                      |                      '<-' source=[State|QNAME]) // implicit ExitEvent
	;
EnterEvent : {EnterEvent}'enter';
ExitEvent : {ExitEvent}'exit';

ScriptEvent : script=SCRIPT_EXPRESSION;

TimerEvent : 't' '>' delay=Expression 'after' event=Event;

Condition : script=SCRIPT_EXPRESSION;

Action : SymbolicAction | ScriptAction | AssignmentAction;

SymbolicAction : name=ID ('after' delay=Expression)? '!';
ScriptAction : script=SCRIPT_STATEMENTS;

VarDef :
	'var' name=ID
	 (':' eType=[ecore::EClassifier|QNAME] (many?=('*'|'[]'))?)?
	 ('=' init=Expression)? ';';

AssignmentAction :
	var=[VarDef|QNAME] '=' value=Expression;

// Expression part of the grammar

terminal SCRIPT_EXPRESSION : '[[' -> ']]';
terminal SCRIPT_STATEMENTS : '{{' -> '}}';

terminal URI_LITERAL         returns EURI: '@'('a'..'z'|'A'..'Z'|'0'..'9'|':'|'_'|'-'|'+'|'.'|'/'|'#'|'?'|'='|'&'|'%'|'@'|'$')+;
terminal EOBJECT_URI_LITERAL returns EURI: 'Û'('a'..'z'|'A'..'Z'|'0'..'9'|':'|'_'|'-'|'+'|'.'|'/'|'#'|'?'|'='|'&'|'%'|'@'|'$')+;

BOOLEAN_LITERAL returns ecore::EBoolean : ('true' | 'false');
FLOAT_LITERAL returns ecore::EDouble: (INT | POS_INT | NEG_INT) '.' INT;
POS_INT returns ecore::EInt: ('+') INT;
NEG_INT returns ecore::EInt: ('-') INT;

QNAME : ID ('.' ID)*;

Expression : Literal | ScriptExpression | EPath;

Literal : BooleanLiteral | FloatLiteral | IntLiteral | StringLiteral | UriLiteral | EObjectUriLiteral | DelayLiteral;

BooleanLiteral    : booleanValue = BOOLEAN_LITERAL;
IntLiteral        : intValue     = (INT | POS_INT | NEG_INT);
FloatLiteral      : floatValue   = FLOAT_LITERAL;
StringLiteral     : stringValue  = STRING;
UriLiteral        : uri          = URI_LITERAL;
EObjectUriLiteral : uri          = EOBJECT_URI_LITERAL;

enum TimeUnit :  ms | s | m | h;
DelayLiteral	  : intValue=INT timeUnit=TimeUnit;

VarRef : var=[VarDef|QNAME];
EPath :
	var=VarRef
	(steps += EStep)*;
	
EStep :
	'/ 'featureName=ID (filter=EStepFilter)?;
	
EStepFilter :
	script=ScriptExpression;

ScriptExpression : script = SCRIPT_EXPRESSION;
